# 复习《算法导论》网易公开课

## 第01课 课程简介

## 第02课 渐近思想与递归

## 第03课 分治法

## 第04课 快排及随机化算法

- 快排是In Place的，不需要额外的空间，简单说就是取个pivot，小的放左边，大的右边，然后递归左右。虽然思想简单，但是自己第一次实现的时候代码会写的比较负责，但是快排的Partition函数实现起来特别精妙，值得反复品味。

- 快报最坏是O(n^2)的，因为随机化后，降到了O(nlogn)，也展示了随机化算法是很强力的

- 快排的实现，值得背：

  ```c++
  int partition(vector<int>& arr, int p, int q) {
      if (p > q)  return -1;
      if (p == q) return p;
      int i = p;
      int j = p + 1;
      for (; j <= q; j++) {
          if (arr[j] < arr[i]) {
              i++;
              swap(arr[i], arr[j]);
          }
      }
      swap(arr[p], arr[i]);
      return i;
  }
  ```

  

## 第05课 线性时间排序

- 讲了很长时间的排序，这节课就讲了背后的原理，很多数学证明，快速浏览即可
- 通过决策树（Decision-tree）的概念，说明了基于比较的排序模型，最好就是O(nlogn)，插入，合并，快速排序都是基于比较的排序
- 在继续看视频前，我想起了分桶排序，这个是O(n)的，但是也明显不是基于比较模型的。
- 分桶排序（Counting sort），分完后，从0...N遍历原始数组，找到当前元素应该在的位置的实现，很精妙
- 基数排序（Radix sort），像打字机，依次排序数字的最后一位到第一位
- 以上2算法，是在特定情况下，非比较模型的O(n)排序，还是稳定的（Stable）

## 第06课 中位数和顺序统计

- 在一个由n个元素组成的集合中，第i个`顺序统计量(order statistic)`是该集合第i个小的元素
- 一个中位数(median)是它所属集合的“中点元素”
- 这节课主要是通过快排的partition过程，先是介绍和分析如果以期望O(n)的时间查找，之后又介绍如果最坏O(n)查找
- 最坏O(n)算法叫，Worst-case linear time order statistics 算法。看课件，算法过程也不复杂，先划分成一个指定的5*X网格，然后递归查找pivot。主要是算法分析有点复杂，略过。
- 上述算法其实想说明中位数在顺序统计中的关键作用（也就是为啥这节课叫这个名字），因为使得partition的划分更平均，能够最终保证O(n)的时间复杂度

## 第07课 哈希表

- 国外的课程比较有理有据的渐进介绍，先是说了现实世界，符号表（Symbol table）是非常常用的数据结构
- 符号表有3个操作：插入（insert），删除（delete）和查找（search）
- 咋实现呢，可以用直接的方式，就是下标0，1，2，3，。。。。最后肯定不行，太长了表炸了
- 这才引出哈希的概念，能够紧凑的映射，但是存在冲突（collision）的问题，可以通过链表法解决
- 其他的就是数学证明了，略过

## 第08课 全域哈希和完全哈希

- 全域哈希：简单来说就是，进程启动的时候是随机选择的哈希函数，这样导致只有天知道具体哪个输入input集合可以使得你的哈希全是冲突，让你的程序很慢
- 接下来就死亡数学证明了，略过
- 完全哈希：结局给定一个静态的输入key集合，在静态数据上造一个哈希表，性能最好的问题
- 总结就是造一个2阶哈希表，然后哈希函数是取自一个集合，集合中的哈希函数满足对于hash_func_a，总能找到hash_func_b是的，a冲突的输入x,y,z，在b绝对没冲突
- 然后又是死亡数学证明了，略过
- 我这次看（2020-05-03），感觉是通过这节课，介绍两个比较“有趣”的哈希理论研究，然后给学生提供一些应用离散数学解决计算机问题的视角，或叫经验

## 第09课 二叉搜索树

- 一笔带过啥是二叉搜索树，然后给出思考如何避免一个树退化成线性，最后提供一种随机化构造树的方案
- 然后开始死亡数学证明，略过
- 我在想，其实平时工程上是不是也可以这样，实现一个简单版的二叉搜索树，但是每个节点记录其深度，root的高度为0，然后有一个树属性变量记录其节点个数和最大深度，当节点个树和最大深度的比值过小，则随机化重新构建树，是不是也不错，避开红黑树平衡树复杂的实现

## 第10课 平衡二叉搜索树

- 开始讲平衡的二叉搜索树，介绍了一堆：avl树，2-3树，2-3-4树，b树，red-black树，skip-list，treaps树堆，有时间了解一下树堆 -。-
- 这节课就是介绍红黑树，红黑树有4个属性
   1. 每个节点都有颜色，不是红色就是黑色，黑节点多
   2. 根节点和叶节点都是黑色的（所以1里说黑节点多）
   3. 每一个红节点的父节点都是黑色的（所以红节点可以向上融合进他的父节点，最后红黑树会变成一个2-3-4树）
   4. 从任何一个节点x到其叶子节点的全部简单路径中包括的黑节点数目都是一样的（保证了3中产生的2-3-4树，所有叶子节点的高度都是一样的）
- 红黑树的实现和证明都太难了，没必要。可以实现跳表连连

## 第11课 如何扩充数据结构

- 不喜欢这节课的中文翻译：扩充的数据结构和区间树，让人一头雾水，其实就是将如何扩充旧的数据结构解决新的问题
- 从这节课开始，整个课程正式进入设计阶段。在现实中很少需要从头创造一个全新的数据结构的情况，基本都可以通过扩充已知的数据结构解决，这节课就是通过2个例子来说明，并总结思考流程
- 第一个： 顺序的动态统计，给一个动态数组（有增加和删除操作），支持2个操作：
  - OS-RANK(X) 返回元素x在数组中的排名
  - OS-SELECT(N) 返回数组中排名是n的元素
- 第二个：区间查找树，给一个动态区间集合（有增加和删除），支持1个操纵：
  - Query([A,B]) 返回集合中overlap 区间 [a,b] 的任意一个区间
- 两个算法都是在红黑树的基础是做的扩展，最后解决红黑树的平衡问题就ok了。之前看到这里我脑海里不停的在暗示自己不可能写一个红黑树来实践这两个东西，但是这次不同的是，我为什么那么追求完美？我直接就用二叉查找树不行吗？不管平衡了，这样就可以实现一版来试试了。
- 并且可以等到跳表那里，再回头来解决平衡问题，还能对比下性能
- 这里简单记录下，扩充数据结构的参考思考流程：
  - 选择一个已知的数据结构作为基础
  - 决定想要附带什么信息到这个基础数据结构上
  - 保证对这个数据结构的操作都能够不破坏其原有特性（比如红黑树的红黑节点，平衡，rotation）
  - 最终，设计出新的操作解决问题（如os-rank, os-select）

## 第12课 跳跃表（skip-list）

- 一个最近出现的，简单的，基于随机化思想的，动态+检索 数据结构。极高的概率保证O(logn)的操作
- 像地铁的快线一样，比如地铁站号1-2-3-4-5-6-7-8，但是2，6站是换成大站，所以加一条特快线2-6，变成2层线路，即：
- 1-2-3-4-5-6-7-8
- 1-2-x-x-x-6-7-8
- 这样，从1到7，那么就应该是1-2-6-7，1-5就应该是1-6-5
- 同样的skiplist有logn层，直觉上，就是O(logn)的操作
- 对于插入一个新元素，先在最后一层（即每个站都有的层）插入，然后抛一个硬币，硬币朝上，就在上一层也插入，然后继续抛硬币直到得到的是背面
- 删除同样就是在最后一层找到，然后一直往上删
- 实现上，使用哨兵节点减少头和尾部特殊条件判定，经典的哨兵节点简化实现的应用
- 以前以为一共就2层，那么实现就很简单，现在发现其实很多层，实现也有点小难度，等到实现了，再来补充

## 第13课

## 第14课

## 第15课

## 第16课

## 第17课

## 第18课

## 第19课



 





