# APUE的学习

### 03 文件IO

- 主要内容：如何通过UNIX提供的文件IO函数，对文件进行操作，主要就是5个：open， read，write，lseek，close，这些也被叫做不带缓冲的IO函数（unbuffered io）
- 术语不带缓冲是指，进程调用read/write时，都是系统调用，需要从用户态切换到内核态，具体理解参见[带缓冲I/O 和不带缓冲I/O的区别与联系](https://blog.csdn.net/yusiguyuan/article/details/23358913) 

- 3.9 讲述了read函数会预读的问题（read ahead）也证实了，不带缓冲指的是在用户态没有缓冲，但是内核还是有缓冲的

- 3.10讲述了文件共享，如果2个进程同时打开一个文件会怎样呢？这里就引出了最关键的一张图，图3-7，即：

  1. 每一个进程有一个自己的打开文件fd表，一个数组，fd标志+fd指针
  2. 内核整体维护一张被打开文件的列表，每一项记录这个文件的状态，偏移量，和一个指向真正文件的指针：V节点指针
  3. 文件在内核中的表示，文件的信息+指向具体磁盘地址的指针

  这里可以理解为，内核维护为打开文件维护一个hashmap，存储少量的V节点信息。每一个文件，都对应一个V节点，存储文件信息和指向数据的指针。

- 所以是有可能两个进程同时打开一个文件的，同时写会造成混乱，引出了原子操作的写，方法介绍了2个：
  - open() + O_APPEND，每次写，都是lseek到尾巴，再写，lseek+write绑在一起
  - pread() pwrite() 原子性定位然后再执行IO

------

### 04 文件和目录

- 主要内容：如何获取修改文件描述信息，各种类型，权限等
- 可以把03，04章理解为，文件是head+body，03章的IO是怎么操作body，即数据。这章是将怎么操作head，即描述信息。自然而然的，目录的body就是目录里放了什么文件，比如vim一个目录
- 全是各种权限设置等，快速过，遇到问题再回来仔细看

------

### 05 标准IO



------

我应该是从2019-06开始正式学习APUE的，读的是英文的教材，并且仔细实践了书里面的例题，课后习题。花费了大量的精力，历时半年，于2019-12（但其实也不是很扎实的）学到了第11章节，如今已是半年后的2020-06



不排除从2020年农历年恢复工作后高强度的需求迭代（个人也有很大成长）导致的时间不足。但还是觉得自己的学习方法有很大问题。在2020-02至04月和朋友进行LeetCode马拉松时，发现自己很多算法知识有所生疏，于是想重新复习下算法4或算法导论，但是书是都看不进去的，最终就是去复习网易的算法导论公开课了（也就是整个mkzoo项目的起源）



由于年后工作繁重，导致个人时间明显不足，所以在复习算法导论公开课时（也就是clrs.md）被迫一改往日追求细节的学习方法，快速的提炼主干，忽略复杂的数学证明，**并且用自己的话总结，这个技术是什么，原理大概是什么，使用场景是什么。**这样让我用非常快的时间复习了头12节课，效果很好，不经意间引起了我自己的反思



不排除之前学习CLRS时是下了功夫的，所以复习才显得容易。但是我之前的学习方法是不是过于抓细枝末节了。最近的工作实践也让我发现，我并不需要完完全全了解某一个技术知识，我的精力是十分有限的，往往只需要了解一个技术知识**它是什么，它大概原理是什么，它解决了啥问题（它的使用场景）**就可以了，真到这个东西成为整个系统的瓶颈时，我再带着问题去研究细节（比如虚表和纯虚函数）往往效果更好



网上的这篇文章[带缓冲I/O 和不带缓冲I/O的区别与联系](https://blog.csdn.net/yusiguyuan/article/details/23358913) 非常好的梳理了我对带缓冲和不带缓冲IO的困惑。同时地引起了我的反思，我反反复复学了好长时间的IO（APUE是在第3，4，5章讲解的IO），最近花了半年时间学习高难度原版APUE，并且进行了大量的编程实践，可是也一直没有理解，或者搞清楚这个概念。所以是不是自己一直以来的学习，是属于为了学习而学习，过于高估自己的精力和脑力去追求细枝末节，往往学着学着，与自己掌握知识的初衷南辕北辙，结果也是半途而废，似是而非呢？



如今，仿照复习CLRS，我为APUE也创建一个Markdown，采用只抓主干方法，重拾APUE的学习，祝自己好运！